# :fire: Spring Boot-JPA

<hr>

### :question: JPA(Java Persistence API)

- 자바 ORM 기술에 대한 표준 명세로, JAVA에서 제공하는 API
- 자바 어플리케이션에서 관계형 데이터베이스를 사용하는 방식을 정의한 인터페이스 ( 라이브러리 x )
- sql 매핑이 아닌, 자바 클래스와 DB테이블을 매핑함

### :question: ORM(Object-Relation Mapping,객체-관계 매핑)

- DB와 Object 필드를 맵핑함
- 객체를 통해 간접적으로 DB 데이터를 다룸
- 객체와 디비의 데이터를 자동으로 매핑함
- SQL 쿼리가 아닌 메소드로 데이터를 조작함.
- JPA, Hibernate

<hr>

### :question: 왜 JPA를 쓰는가

:rage: <b> sql 중심 (과거) </b>

<b> 1. 반복 </b>

- DB에 객체 CRUD 작업을 하려면 너무 많은 SQL과 JDBC API 코드를 반복해야 한다.

- DB 테이블이 100개라면 위 작업을 100번 반복해야 하는 것이다.

<b> 2. SQL에 의존적인 개발 </b>

- 엔티티를 신뢰할 수 없음

- 진정한 의미의 계층 분할이 어렵다

- 필드를 하나 추가 할 때도 DAO의 CRUD 코드와 SQL 대부분을 변경해야 한다.


<b> 3. 패러다임의 불일치 </b>

- 객체와 관계형 DB는 지향하는 목적이 서로 다르다. 둘의 기능과 표현 방법도 다르다.

- 객체 구조를 테이블 구조로 저장하는 데는 한계가 있다. 이것이 객체와 관계형DB의 패러다임 불일치 문제이다.

<hr>

:smirk: <b> JPA (현재) </b>

- 자바 객체와 DB 테이블 사이의 매핑 설정을 통해 SQL을 생성한다.
- 객체를 통해 쿼리를 작성할 수 있는 JPQL(Java Persistence Query Language)를 지원
- sql 중심적인 개발에서 객체 중심적인 개발이 가능하다. 따라서 개발자는 비즈니스 로직에 집중할 수 있다.

:muscle: 생산성이 증가

:muscle: 간단한 메소드로 CRUD가 가능하다

:muscle: 유지보수가 쉽다

:muscle: Object와 RDB 간의 패러다임 불일치를 해결한다.

<hr>

### :question: 영속성 컨텍스트

- 엔티티를 영구 저장하는 환경. 엔티티 매니저로 엔티티를 저장하거나 조회하면 엔티티 매니저는 영속성 컨테스트에 엔티티를 보관하고 관리한다.
- 영속성 컨텍스트는 엔티티 매니저를 생성할 때 하나만 만들어진다. 엔티티 매니저를 통해 영속성 컨텍스트에 접근할 수 있고, 관리할 수 있다.

#### :bulb: 비영속: 영속성 컨텍스트와 관계 없는 상태
- 엔티티 객체만 생성했고, 순수한 객체 상태이며 저장하지 않았다.
#### :bulb: 영속: 영속성 컨텍스트에 저장된 상태
- 엔티티 매니저를 통해 엔티티를 영속성 컨텍스트에 저장했다.
#### :bulb: 준영속: 영속성 컨텍스트에 저장되었다가 분리된 상태
- 영속성 컨텍스트가 더 이상 관리하지 않는 상태이다. em.detach()를 호출하거나 em.close()를 호출해서 영속성 컨텍스트를 닫거나, em.clear()로 영속성 컨텍스트를 초기화하면 준영속 상태가 된다.
- em.detach(entity) : 특정 엔티티만 준영속 상태로 전환
- em.clear() : 영속성 컨텍스트를 완전히 초기화
- em.close() : 영속성 컨텍스트르 종료한다.
- 비영속 상태에 가깝다 영속성 컨텍스트가 지원하는 어떤 기능도 동작x
- 식별자 값을 가지고 있다.
- 지연 로딩을 할 수 없다.
- 다시 영속 상태로 변경하려면 merge()를 사용하면 되ㅏㄴ다.
#### :bulb: 삭제: 삭제된 상태
- 엔티티를 영속성 컨텍스트와 DB에서 삭제한다.

![image](https://user-images.githubusercontent.com/66015002/118460639-d932c700-b737-11eb-9f81-d7cfc397c322.png)


#### :muscle: 영속성 컨텍스트는 엔티티를 식별자 값(id값)으로 구분한다. 따라서 영속 상태는 식별자 값이 반드시 있어야 된다.

#### :muscle: 영속성 컨텍스트에 엔티티를 저장하고 flush를 통해 DB에 저장한다.

#### :muscle: 영속성 컨텍스트가 엔티티를 관리하면 1차캐시 , 동일성 보장 , 트랙잭션을 지원하는 쓰기 지연 , 변경감지 , 지연 로딩 기능을 사용할 수 있다.

> - em.find()를 호출하면 먼저 1차 캐시에서 엔티티를 찾고 없으면 DB에서 조회한다. 그리고 1차 캐시에 저장한 후 영속 상태의 엔티티를 반환한다.

(참고) 동일성: 실제 인스턴스가 같은 것. ==  , 동등성: 실제 인스턴스는 다를 수 있지만 갖고 있는 값이 같은 것. equals()

> - 데이터를 메모리에 저장해두었다가 트랜잭션을 커밋할 때 모아둔 등록 쿼리를 db에 보낸 후에 커밋하는 트랙잭션을 지원하는 쓰기 지연

> - 엔티티의 변경사항을 DB에 자동으로 반영하는 변경감지
1. 트랙잭션을 커밋하면 엔티티 매니저 내부에서 flush가 호출된다.
2. 엔티티와 스냅샷을 비교해서 변경된 엔티티를 찾는다
3. 변경된 엔티티가 있으면 수정 쿼리를 생성해서 쓰기 지연 SQL저장소에 보낸다
4. 쓰기 지연 저장소의 SQL을 DB로 보낸다
5. 데이터베이스 트랜잭션을 커밋한다.

